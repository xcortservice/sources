# generated by datamodel-codegen:
#   filename:  response.json
#   timestamp: 2024-08-07T23:15:31+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional

import feedparser
from aiohttp import ClientSession
from pydantic import BaseModel
from typing_extensions import Self


class TitleDetail(BaseModel):
    type: Optional[str] = None
    language: None = None
    base: Optional[str] = None
    value: Optional[str] = None


class Link(BaseModel):
    rel: Optional[str] = None
    href: Optional[str] = None
    type: Optional[str] = None


class Author(BaseModel):
    name: Optional[str] = None
    href: Optional[str] = None


class AuthorDetail(BaseModel):
    name: Optional[str] = None
    href: Optional[str] = None


class MediaContentItem(BaseModel):
    url: Optional[str] = None
    type: Optional[str] = None
    width: Optional[str] = None
    height: Optional[str] = None


class MediaThumbnailItem(BaseModel):
    url: Optional[str] = None
    width: Optional[str] = None
    height: Optional[str] = None


class SummaryDetail(BaseModel):
    type: Optional[str] = None
    language: None = None
    base: Optional[str] = None
    value: Optional[str] = None


class MediaStarrating(BaseModel):
    count: Optional[str] = None
    average: Optional[str] = None
    min: Optional[str] = None
    max: Optional[str] = None


class MediaStatistics(BaseModel):
    views: Optional[str] = None


class FeedEntry(BaseModel):
    id: Optional[str] = None
    guidislink: Optional[bool] = None
    link: Optional[str] = None
    yt_videoid: Optional[str] = None
    yt_channelid: Optional[str] = None
    title: Optional[str] = None
    title_detail: Optional[TitleDetail] = None
    links: Optional[List[Link]] = None
    authors: Optional[List[Author]] = None
    author_detail: Optional[AuthorDetail] = None
    href: Optional[str] = None
    author: Optional[str] = None
    published: Optional[str] = None
    published_parsed: Optional[List[int]] = None
    updated: Optional[str] = None
    updated_parsed: Optional[List[int]] = None
    media_content: Optional[List[MediaContentItem]] = None
    media_thumbnail: Optional[List[MediaThumbnailItem]] = None
    summary: Optional[str] = None
    summary_detail: Optional[SummaryDetail] = None
    media_starrating: Optional[MediaStarrating] = None
    media_statistics: Optional[MediaStatistics] = None
    media_community: Optional[str] = None


class Feed(BaseModel):
    links: Optional[List[Link]] = None
    id: Optional[str] = None
    guidislink: Optional[bool] = None
    link: Optional[str] = None
    yt_channelid: Optional[str] = None
    title: Optional[str] = None
    title_detail: Optional[TitleDetail] = None
    authors: Optional[List[Author]] = None
    author_detail: Optional[AuthorDetail] = None
    href: Optional[str] = None
    author: Optional[str] = None
    published: Optional[str] = None
    published_parsed: Optional[List[int]] = None


class Namespaces(BaseModel):
    yt: Optional[str] = None
    media: Optional[str] = None
    field_: Optional[str] = None


class YouTubeFeed(BaseModel):
    bozo: Optional[bool] = None
    entries: Optional[List[FeedEntry]] = None
    feed: Optional[Feed] = None
    headers: Optional[Dict[str, Any]] = None
    encoding: Optional[str] = None
    version: Optional[str] = None
    namespaces: Optional[Namespaces] = None

    @classmethod
    async def from_id(cls, channel_id: str) -> Optional[Self]:
        async with ClientSession() as session:
            async with session.get(
                "https://www.youtube.com/feeds/videos.xml",
                params={"channel_id": channel_id},
            ) as response:
                data = await response.text()
        return cls(**feedparser.parse(data))
